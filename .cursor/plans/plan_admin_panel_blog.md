# Plan: Admin Panel for Personal Blog

## Project Overview

Build a protected **admin panel** for the personal website that allows editing the hero/summary, resume, certifications, and blog content; **writing blog posts** using Google Gemini with standardized English and Turkish prompts; and **sharing posts to LinkedIn** (immediate share and optional scheduling). The panel will integrate with existing file-based data (`content/resume/resume.json`, `content/blog/*.mdx`) and add API routes for Gemini and LinkedIn where needed.

**Goals:**

1. Update name and summary in the first section (hero).
2. Update resume section (experience, education, skills, etc.).
3. Update certifications and achievements.
4. Manage blogs (list, create, edit, delete).
5. Write blogs using Gemini with a standard prompt and context (EN/TR prompts provided).
6. Share blog posts to LinkedIn via LinkedIn API for both immediate and scheduled sharing; post text generated by Gemini (user can override).

---

## Scope & Environment

- **Framework:** Next.js 15+ (App Router)
- **Language:** TypeScript 5.7.2
- **Styling:** Tailwind CSS 3.4.17
- **Package Manager:** PNPM (always)
- **Existing Data:**
  - Hero + resume + certifications: `content/resume/resume.json` (single JSON; `getResumeData()` in `lib/resume.ts`)
  - Blog posts: `content/blog/*.mdx` (gray-matter frontmatter + body; `lib/mdx.ts` — `getAllPosts`, `getPostBySlug`)
- **Current Gaps:**
  - No authentication (admin must be protected)
  - No Gemini SDK
  - No server-side write helpers for resume.json or blog MDX (read-only today)
  - Performance: `getAllPosts()` reads all files + full content on every request (slow with many posts)

**New Dependencies (to add):**

- Authentication: `next-auth` (v5 / Auth.js) for protecting `/admin` routes — compatible with Next.js 15+
- Validation: `zod` — not in current `package.json`; required for API/action payload validation per plan
- Gemini: `@google/generative-ai` for blog generation
- Git integration: `simple-git` (or Node.js `child_process` with `git` command) for commit + push automation
- LinkedIn API: OAuth 2.0 flow and UGC Post API for scheduled sharing; cron or external scheduler to post at scheduled time

---

## Persistence Strategy

**Approach: File-based + Git + JSON Index**

- **Source of Truth:** Files (`content/resume/resume.json`, `content/blog/*.mdx`)
- **Persistence:** Write directly to files on server
- **Backup/Versioning:** Git commit + push after each admin save
- **Performance:** JSON index (`content/blog/.index.json`) for fast list queries

### How It Works

1. **Admin edits** → Server writes to files (`resume.json` or `{slug}.mdx`)
2. **After write** → Rebuild JSON index (if blog post changed)
3. **After write** → Git commit + push (atomic: files + index together)
4. **Public reads** → Use JSON index for list pages (fast), read full MDX only for single post pages

### JSON Index Structure

```typescript
// content/blog/.index.json
{
  "posts": [
    {
      "slug": "post-slug",
      "title": "Post Title",
      "description": "Post description",
      "date": "2026-01-28",
      "tags": ["tag1", "tag2"],
      "locale": "en",
      "alternateLocale": "tr",
      "alternateSlug": "post-slug-tr",
      "readingTime": 5
      // Note: NO content field (only metadata)
    }
  ],
  "lastUpdated": "2026-01-28T12:00:00.000Z",
  "version": "1.0"
}
```

### Benefits

- ✅ **Fast list queries:** Single JSON read instead of reading 100+ files
- ✅ **Low memory:** Only metadata loaded, not full content
- ✅ **Git-friendly:** Index file committed with posts (single source of truth)
- ✅ **No database:** Pure file-based, works with git workflow
- ✅ **Backward compatible:** Can still read MDX files directly if index missing

### Index Rebuild Strategy

- **Rebuild on:** Blog create, edit, delete (admin actions)
- **Rebuild process:** Read all `.mdx` files, extract frontmatter only, write `.index.json`
- **Git integration:** Commit index file with the changed post(s) in same commit
- **Fallback:** If index missing or corrupted, rebuild on-the-fly (slower but works)

---

## Interface Specifications

### 1. Resume / Hero (existing, extend usage)

Use existing `ResumeData` from `lib/resume.ts`. Admin will edit:

- **Hero / first section:** `personal` (name, title, tagline, email, location, website, linkedin, github), `summary`
- **Resume section:** `experience`, `education`, `coreSkills`, `keyStrengths`, `workWithMe`, `skills`, optional `aiMlopsExperience`, `caseStudy`
- **Certifications:** `certifications` array (name, version?, issuer, issueDate?, expirationDate?, credentialId?, credentialUrl?, skills?)

No new types required; validate with Zod (add `zod` dependency) for API payloads using the same shape.

### 2. Blog Post (existing + create/update payloads)

Existing `BlogPost` in `lib/mdx.ts`: `slug`, `title`, `description`, `date`, `tags`, `readingTime`, `content`, `locale`, `alternateLocale?`, `alternateSlug?`.

**New Types:**

```typescript
// Metadata-only (for list pages, from JSON index)
type BlogPostMetadata = {
  slug: string
  title: string
  description: string
  date: string
  tags: string[]
  readingTime: number
  locale: 'en' | 'tr'
  alternateLocale?: 'en' | 'tr'
  alternateSlug?: string
  // NO content field
}

// Payload for create/update (API or form)
type BlogPostPayload = {
  slug: string
  title: string
  description: string
  date: string
  tags: string[]
  locale: 'en' | 'tr'
  alternateLocale?: 'en' | 'tr'
  alternateSlug?: string
  content: string
}

// JSON Index structure
type BlogIndex = {
  posts: BlogPostMetadata[]
  lastUpdated: string
  version: string
}
```

Frontmatter in MDX must match: `title`, `description`, `date`, `tags`, `locale`, `alternateLocale?`, `alternateSlug?`.

**New Functions:** Add to `lib/mdx.ts` or `lib/blog-index.ts` (single module preferred for index logic):

```typescript
// Read from JSON index (fast); fallback to rebuild if index missing/corrupt
export function getAllPostsMetadata(): BlogPostMetadata[]

// Rebuild index from MDX files (admin use); use fs.promises for async writes
export function rebuildBlogIndex(): Promise<void>

// Check if index needs rebuild (compare file mtimes vs index lastUpdated)
export function shouldRebuildIndex(): boolean
```

**Compatibility:** `prioritizePostsByLocale` and `getPostsByLocale` must accept `BlogPostMetadata[]` (they only use `slug`, `locale`, `alternateSlug`, `date`). Either type the parameter as `BlogPostMetadata[]` where used for lists, or use a generic `T extends { slug: string; locale: 'en'|'tr'; alternateSlug?: string; date: string }`. Update `getAllTags()` to derive from `getAllPostsMetadata()` (tags are in metadata). Update `app/blog/[slug]/page.tsx` `generateStaticParams` to use `getAllPostsMetadata().map(p => ({ slug: p.slug }))`.

### 3. Gemini Blog Generation

```typescript
type GeminiBlogRequest = {
  locale: 'en' | 'tr'
  rawContext: string
  primaryKeyword: string
  targetAudience: string
  desiredWordCount: number
  cta: string
}

type GeminiBlogResponse = {
  markdown: string
  headlineOptions?: string[]
}
```

Prompts (EN/TR) will be stored as constants or in a small config module; the API will inject `rawContext`, `primaryKeyword`, `targetAudience`, `desiredWordCount`, and `cta` into the chosen prompt template.

### 4. LinkedIn

**Both immediate and scheduled sharing use the LinkedIn API.** Post text is generated by Gemini (from blog title/description); user can override. See "Post text via Gemini" below.

**Immediate share (via API):** Admin clicks Share → if not connected, prompt to connect → generate post text via Gemini (or user override) → call UGC Post API → show success or failure.

**Scheduled share (via API):** At cron time, for each pending item generate post text via Gemini if no custom text, then call UGC Post API.

- **OAuth 2.0:** Admin connects their LinkedIn account via OAuth 2.0. Required scope: **`w_member_social`** (Share on LinkedIn). Create an app in LinkedIn Developer Portal, add "Share on LinkedIn" product, use OAuth 2.0 authorization code flow.
- (Share URL is optional fallback only; primary flow uses API.)
- **Token storage:** Store access and refresh tokens server-side only (e.g. encrypted file under `content/admin/` in `.gitignore`, or env vars). Never commit tokens to git.
- **Post text via Gemini:** When sharing (immediate or scheduled), generate LinkedIn post text using Gemini. Input: blog title, description, optional tone/hint, locale (EN/TR). Output: short, engaging post copy (max 3000 chars). Store prompt in `lib/gemini-prompts.ts` (e.g. "LinkedIn post" prompt). Endpoint e.g. `POST /api/admin/gemini/linkedin-post` with `{ postSlug }` or `{ title, description, locale }`; returns `{ text }`. User can override with custom text in UI before posting.
- **Posting:** Use LinkedIn UGC Post API (`POST https://api.linkedin.com/v2/ugcPosts`). Payload: `author` (person URN from `/v2/me`), `lifecycleState: "PUBLISHED"`, `visibility: { "com.linkedin.ugc.MemberNetworkVisibility": "PUBLIC" }`, `specificContent.com.linkedin.ugc.ShareContent`: `shareCommentary.text` (Gemini-generated or user override, max 3000 chars), `shareMediaCategory: "ARTICLE"`, `media`: one item with `landingPage: { landingPageUrl: blogUrl, landingPageTitle: postTitle }`, `status: "READY"`. Store response UGC Post ID as `linkedInPostId` when applicable.
- **Immediate share:** Admin clicks "Share on LinkedIn" → if not connected, prompt to connect → call Gemini to generate post text (or use user-provided text) → call UGC Post API immediately → show success (link to post) or failure.
- **Scheduled share:** At scheduled time, cron loads pending items → for each: if no custom text, call Gemini to generate post text from blog metadata; else use stored custom text → obtain token, call UGC Post API → update status and `linkedInPostId` or `errorMessage`.

```typescript
type LinkedInScheduledPost = {
  id: string
  postSlug: string
  scheduledAt: string
  status: 'pending' | 'published' | 'cancelled' | 'failed'
  createdAt: string
  linkedInPostId?: string
  errorMessage?: string
}
```

---

## Step-by-Step Execution Plan

### Phase 1: Foundation (Auth + Admin Layout)

1. **Add authentication**
   - Install and configure NextAuth (or chosen auth) with a credentials provider (e.g. env `ADMIN_EMAIL`, `ADMIN_PASSWORD`) or OAuth.
   - Protect all routes under `/admin` (middleware or layout-level session check).
   - **Verification:** Unauthenticated access to `/admin` redirects to login; authenticated user sees admin layout.

2. **Create admin layout and navigation**
   - Route: `app/admin/layout.tsx` — server component that checks session; redirect if not authenticated.
   - Sidebar/nav: Hero & Summary, Resume, Certifications, Blog List, Write with Gemini, LinkedIn (Share & Schedule).
   - **Verification:** All admin links render and navigate without 404.

### Phase 2: Hero & Summary

3. **Hero and summary edit page**
   - Page: `app/admin/hero-summary/page.tsx` (or under a group like `app/admin/(content)/hero-summary/page.tsx`).
   - Load `getResumeData()` and bind to form: `personal.name`, `personal.title`, `personal.tagline`, `personal.email`, `personal.location`, `personal.website`, `personal.linkedin`, `personal.github`, `summary`.
   - Form: client component with controlled inputs; submit via server action or `POST /api/admin/resume`.
   - **Verification:** After save, home page hero and summary reflect changes.

4. **API or server action to update resume (partial)**
   - Either `PATCH /api/admin/resume` (accept partial `ResumeData`) or a server action that reads `content/resume/resume.json`, merges payload, validates with Zod, writes back.
   - Ensure atomic write (e.g. write to temp file then rename) to avoid corruption.
   - **Verification:** Updating only `summary` or only `personal.name` does not wipe other fields.

### Phase 3: Resume Section

5. **Resume section edit page**
   - Page: `app/admin/resume/page.tsx`. Load full resume; form for `experience`, `education`, `coreSkills`, and any other resume fields displayed on the site.
   - Use dynamic list UI (add/remove entries) for `experience`, `education`, `certifications` (or link to certifications page).
   - Reuse same resume update API/action as step 4.
   - **Verification:** Changes to experience/education appear on home resume section.

### Phase 4: Certifications and Achievements

6. **Certifications edit page**
   - Page: `app/admin/certifications/page.tsx`. List `resume.certifications`; add/edit/delete entries (name, version, issuer, issueDate, expirationDate, credentialId, credentialUrl, skills).
   - Submit via same resume update API/action (update only `certifications` or full resume).
   - **Verification:** Certifications section on home shows added/edited/removed items.

### Phase 5: Blog Management

7. **Implement JSON index system**
   - Create `lib/blog-index.ts` (or extend `lib/mdx.ts`) with: `getAllPostsMetadata()` (read from `content/blog/.index.json`; fallback: rebuild if missing/corrupt), `rebuildBlogIndex()` (scan `.mdx` files, extract frontmatter only, write index using `fs.promises` and atomic write), `shouldRebuildIndex()` (compare file mtimes vs index `lastUpdated`).
   - Ensure `content/blog/.index.json` is versioned (do not add to `.gitignore`).
   - Update `getAllTags()` and `getPostsByLocale()` to use metadata source (index or existing logic with metadata type). Ensure `prioritizePostsByLocale` works with `BlogPostMetadata[]` (same shape for slug, locale, alternateSlug, date).
   - Update public pages: `app/blog/page.tsx`, `components/home/latest-blogs-section.tsx`, `components/blog/related-posts.tsx`, `components/home/featured-posts.tsx` (if used) to use `getAllPostsMetadata()` for list/related views. Update `app/blog/[slug]/page.tsx` `generateStaticParams` to use `getAllPostsMetadata().map(p => ({ slug: p.slug }))`.
   - Keep `getPostBySlug()` unchanged (reads full MDX for single post pages).
   - **Verification:** List pages load fast (single JSON read); single post and related posts work; index rebuilds correctly; `generateStaticParams` uses metadata.

8. **Blog list and actions**
   - Page: `app/admin/blogs/page.tsx`. List all posts from `getAllPostsMetadata()` (fast, from index) with columns: title, slug, date, locale, tags; actions: Edit, Delete, “Share on LinkedIn”.
   - Delete: confirm then remove file `content/blog/{slug}.mdx`, then call `rebuildBlogIndex()`, then git commit + push.
   - **Verification:** Deleting a post removes it from blog list and `/blog/[slug]`; index updates; git commit includes deleted file + updated index.

9. **Blog create/edit page**
   - Route: `app/admin/blogs/new/page.tsx` and `app/admin/blogs/[slug]/edit/page.tsx` (or single `app/admin/blogs/[slug]/page.tsx` with slug `new` for create).
   - Form: slug, title, description, date, tags, locale, alternateLocale, alternateSlug, body (MDX content). On create, slug must be unique; on edit, slug change may require redirect or rename file.
   - Save: write `content/blog/{slug}.mdx` with gray-matter frontmatter and body. Use Zod to validate payload. After write, call `rebuildBlogIndex()`, then git commit + push (atomic: MDX + index).
   - **Verification:** New post appears in blog list and on `/blog/[slug]`; edit updates existing post; index updates; git commit includes both files.

### Phase 6: Write Blogs with Gemini

10. **Store prompts and add Gemini API**
   - Add `@google/generative-ai`. Create `lib/gemini-prompts.ts` (or similar) with two prompt templates: English and Turkish for blog articles; plus LinkedIn post-text prompts (title/description → short post copy, max 3000 chars). Full text from user’s EN/TR prompts). Placeholders: `[PASTE YOUR RAW NOTES...]`, `[INSERT KEYWORD]`, `[e.g. Technical Leads...]`, `[e.g. 800 words]`, `[e.g. Sign up...]`.
   - **Verification:** Prompt modules export correct strings and placeholders are replaceable.

11. **Gemini generate endpoint and UI**
    - `POST /api/admin/gemini/generate` (or `/api/admin/blog/generate`): body `GeminiBlogRequest`. Validate with Zod. Replace placeholders in the selected prompt with `rawContext`, `primaryKeyword`, `targetAudience`, `desiredWordCount`, `cta`. Call Gemini; return `{ markdown }` (and optionally parsed headline options). Return 400 on validation failure.
    - Env: `GEMINI_API_KEY`.
    - **Verification:** Request with sample context returns markdown in the expected structure (headlines, takeaways, body, CTA).

12. **“Write with Gemini” admin page**
    - Page: `app/admin/blogs/write-with-gemini/page.tsx`. Form: locale (EN/TR), raw context (textarea), primary keyword, target audience, word count, CTA. Button “Generate”. Display result in a preview; button “Save as draft” that goes to blog create form with pre-filled content (and optional title from first headline).
    - **Verification:** Generated markdown can be saved as a new blog post.

12b. **Gemini LinkedIn post text endpoint**
    - `POST /api/admin/gemini/linkedin-post`: body `{ postSlug }` or `{ title, description, locale?, toneHint? }`. Load blog metadata if postSlug provided; call Gemini with LinkedIn post-text prompt; return `{ text }` (max 3000 chars). Used by immediate share and by cron for scheduled posts when no custom text is stored.
    - **Verification:** Request returns engaging post text suitable for LinkedIn shareCommentary.

### Phase 7: LinkedIn Share and Scheduling

13. **Share on LinkedIn (immediate, via API)**
    - From blog list or blog detail in admin: “Share on LinkedIn” uses LinkedIn API (not share URL). Require LinkedIn OAuth connected (task 14); if not, prompt to connect. Call Gemini to generate post text from blog title/description (or use user-provided text in modal); then call UGC Post API to create post immediately. Show success (link to new LinkedIn post) or failure.
    - **Verification:** Click creates a real LinkedIn post via API with Gemini-generated (or user override) post text; success shows link to post.

14. **LinkedIn OAuth connect**
    - Create LinkedIn app in LinkedIn Developer Portal; add "Share on LinkedIn" product; obtain client ID and client secret. Env: `LINKEDIN_CLIENT_ID`, `LINKEDIN_CLIENT_SECRET`, redirect URI (e.g. `/admin/linkedin/callback`).
    - Implement OAuth 2.0 authorization code flow: admin page "Connect LinkedIn" redirects to LinkedIn consent URL (scope `w_member_social`); callback route exchanges code for access + refresh token; store tokens server-side only (encrypted file in `content/admin/` with filename in `.gitignore`, or secure env). Optionally store person URN from `/v2/me` for author field.
    - Admin UI: show "Connected" if tokens exist; "Connect LinkedIn" / "Reconnect" button otherwise. Do not expose tokens to client.
    - **Verification:** Admin can connect LinkedIn; tokens stored server-side; person URN available for UGC Post author.

15. **LinkedIn scheduling (API posting)**
    - Data: store scheduled posts in `content/admin/scheduled-linkedin.json` (git-tracked). Fields: `id`, `postSlug`, `scheduledAt`, `status` (pending | published | cancelled | failed), `createdAt`, optional `linkedInPostId`, optional `errorMessage`. Do not store LinkedIn tokens in this file.
    - UI: On blog list or edit, “Schedule share” opens modal/page to pick date/time and optional custom post text (max 3000 chars); save to JSON; git commit + push.
    - Cron (e.g. Vercel Cron `app/api/cron/linkedin-schedule/route.ts`) or external scheduler runs every N minutes; for each `scheduledAt <= now` and `status === 'pending'`: load blog metadata for postSlug; if no custom text stored, call Gemini to generate post text from blog title/description (same `POST /api/admin/gemini/linkedin-post` or inline); else use stored custom text; obtain valid access token (refresh if expired); call LinkedIn UGC Post API with author (person URN), shareCommentary.text (Gemini-generated or custom, max 3000 chars), shareMediaCategory ARTICLE, media with landingPage (blogUrl, title); on success set status published and linkedInPostId; on failure set status failed and errorMessage; persist updated JSON.
    - **Verification:** Scheduled item appears in list; at scheduled time (or manual trigger), post is created on LinkedIn via API; status and linkedInPostId updated; failures recorded.

### Phase 8: Git Integration

16. **Git commit and push automation**
    - **Note:** This is integrated into previous phases (resume updates, blog create/edit/delete). This phase documents the implementation details.
    - Create `lib/git-utils.ts` with `gitCommitAndPush(files: string[], message: string)`. Use Node.js `child_process` or `simple-git`; sanitize inputs (no user-supplied data in commit messages — use fixed prefixes e.g. "admin: update resume").
    - After each admin save (resume, blog create/edit/delete, LinkedIn schedule): commit changed files + index, then push to remote. On push failure (e.g. network), do not fail the admin save; persist failure state or log for manual push later.
    - Env: `GIT_REPO_PATH` (default: `process.cwd()`), `GIT_USER_NAME`, `GIT_USER_EMAIL` (for commits).
    - **Deployment note:** Git write/push from the server requires a writable repo and `git` available (e.g. Node server, Docker, or CI). Not supported on Vercel serverless (read-only filesystem). For Vercel, either run admin locally and push from client machine, or use a webhook to trigger CI that pulls and pushes from a writable runner.
    - **Verification:** Admin saves trigger git commit + push where environment supports it; failed pushes do not break admin workflow.

### Phase 9: Error Handling and i18n

17. **Admin error boundaries and validation**
    - Add `app/admin/error.tsx` (client component: `'use client'`, same pattern as `app/error.tsx` — receive `error`, `reset`, render user-friendly message and "Try again" button). Add `app/admin/not-found.tsx` if admin routes need custom 404. Use Zod for all admin API/action payloads; return 400 with validation message on failure.
    - **Next.js 15+:** Admin dynamic routes (e.g. `app/admin/blogs/[slug]/edit/page.tsx`) must use `params: Promise<{ slug: string }>` and `const { slug } = await params` per project conventions.
    - **Verification:** Invalid payload returns 400 with clear error; runtime errors show error boundary; admin dynamic routes type params as Promise.

18. **Admin copy and optional i18n**
    - Project does not currently use `next-intl` (not in `package.json`). Keep admin UI in one language (e.g. English) unless i18n is added later; document in plan.
    - **Verification:** Buttons and labels are consistent and readable.

---

## Verification Criteria Summary

| Task | Verification |
|------|--------------|
| Auth | Unauthenticated user cannot access `/admin`; login works. |
| Hero & Summary | Edits to name/summary appear on home hero. |
| Resume update | Experience/education edits appear on home resume section. |
| Certifications | Add/edit/delete certifications; home certifications section updates. |
| JSON index | List pages load fast (single JSON read); index rebuilds on admin edits. |
| Blog list | All posts listed (from index); delete removes file, updates index, commits to git. |
| Blog create/edit | New post appears at `/blog/[slug]`; edit updates content; index rebuilds; git commits. |
| Git integration | Admin saves trigger git commit + push; atomic commits (files + index together). |
| Gemini generate | Sample request returns valid markdown (headlines, body, CTA). |
| Save from Gemini | Generated content can be saved as new MDX post. |
| LinkedIn share | “Share on LinkedIn” creates post via LinkedIn API with Gemini-generated (or user override) post text; success shows link to post. |
| LinkedIn OAuth | Admin can connect LinkedIn; tokens stored server-side; person URN available. |
| LinkedIn schedule | Scheduled items stored; cron uses Gemini for post text when no custom text; posts to LinkedIn via UGC Post API; status and linkedInPostId updated. |
| Errors | Invalid input returns 400; unhandled errors show error boundary. |

---

## Best Practices and Notes

- **DRY:** Reuse `getResumeData()`, `getAllPostsMetadata()` (for lists), `getPostBySlug()` (for single posts); add server-side helpers only for *writing* (e.g. `writeResumeData`, `writeBlogPost`, `deleteBlogPost`, `rebuildBlogIndex`).
- **Performance:** Use `getAllPostsMetadata()` for list pages (reads JSON index); use `getPostBySlug()` only for single post pages (reads full MDX). Index rebuilds only on admin edits, not on reads.
- **Security:** Never expose `GEMINI_API_KEY` or auth secrets to the client. All resume/blog writes and Gemini calls must be server-side (API or server actions). Git operations must sanitize inputs (no user data in commit messages).
- **Files:** Use `fs.promises` and atomic writes where possible (write temp file, then `rename`) for `resume.json`, MDX files, and `.index.json`. Ensure index file is always valid JSON (catch parse errors, rebuild on corruption).
- **Git:** Commit files + index together atomically. Use descriptive commit messages (e.g. "admin: update resume summary", "admin: create blog post 'new-post'"). Handle git errors gracefully (log but don't fail admin save).
- **Index Maintenance:** Index rebuild is fast (reads frontmatter only, ~1-2 lines per file). If index is missing/corrupted, rebuild on-the-fly (slower but works). Consider adding index version check on startup (compare file mtimes).
- **Next.js 15+:** Use Server Components for admin layout and data loading; Client Components only for forms and interactive lists. Use server actions or route handlers for mutations.
- **LinkedIn API:** Full “post on behalf of user” and scheduling via API require LinkedIn Developer App and OAuth. This plan prioritizes share URL + optional scheduling store; Scheduled sharing uses LinkedIn UGC Post API with OAuth 2.0 (w_member_social); tokens server-side only; cron posts at scheduled time. Both immediate and scheduled use LinkedIn API; post text generated by Gemini (user can override).

---

## Optional Follow-ups

- Add rate limiting for Gemini API and admin APIs.
- Add audit log for admin actions (who changed what and when) — can use git history or separate JSON log file.
- Add index health check endpoint (`GET /api/admin/blog-index/health`) to verify index is up-to-date.
- Add manual "Rebuild Index" button in admin (useful if index gets out of sync).
- Migrate scheduled posts to a real DB if scaling beyond a few dozen entries.
- Apply i18n to admin UI if the rest of the site is localized.
- Consider adding index compression (gzip) if index file grows very large (1000+ posts).

---

## Review Notes (Technical Audit)

**Compatibility & version audit**

- **Dependencies:** Plan now explicitly adds `zod` (not in current `package.json`) for validation. NextAuth referenced as v5 / Auth.js for Next.js 15+ compatibility. `@google/generative-ai`, `simple-git` (or `child_process`) remain as stated.
- **Next.js 15+:** Admin dynamic routes (e.g. `app/admin/blogs/[slug]/edit/page.tsx`) must use `params: Promise<{ slug: string }>` and `await params` per project rules; added to Phase 9 (error handling) task 16.
- **Pattern alignment:** Admin `error.tsx` must follow existing `app/error.tsx` pattern (`'use client'`, `error`/`reset` props, user-friendly message, Try again button). No Card/Button from shadcn in current root error — plan does not mandate shadcn for admin; use existing patterns.

**Technical quality & risk**

- **Reuse:** Plan now specifies updating `getAllTags()`, `getPostsByLocale()`, `prioritizePostsByLocale` to work with `BlogPostMetadata[]`; `generateStaticParams` and all list/related consumers (`app/blog/page.tsx`, `latest-blogs-section`, `related-posts`, `featured-posts`) to use `getAllPostsMetadata()`. Single-post pages and `getPostBySlug()` unchanged — avoids duplicating logic.
- **Risks:** (1) Git commit/push from server requires writable repo and `git` (not supported on Vercel serverless); deployment note added to Phase 8. (2) `.index.json` must be versioned — explicit note to not add to `.gitignore`. (3) LinkedIn share URL fixed to use `siteConfig.url` and `encodeURIComponent` for correctness.
- **Security:** Commit messages must not include user-supplied data; use fixed prefixes (e.g. "admin: update resume"). Zod validation on all admin API/action payloads; 400 on failure.
- **Consistency:** File writes use `fs.promises` and atomic write (temp file + rename) for new code. Existing `lib/mdx.ts` and `lib/resume.ts` use sync `fs`; new index and write helpers should use async where added. Admin error boundary aligned with existing `app/error.tsx` style.
- **Validation:** Project has no Zod or centralized logger today; plan adds Zod. Logger for admin/git errors not mandated (project has no `lib/logging`); optional follow-up or use `console.error` in dev until logger exists.

**Refinements applied**

- Removed duplicate "Create lib/git-utils.ts" line in Phase 8.
- Renumbered Phase 6 tasks 10 → 11, 11 → 12 to fix duplicate "10.".
- Renumbered Phase 7 tasks 12 → 13, 13 → 14.
- Added explicit call sites for metadata (related-posts, featured-posts, generateStaticParams) and compatibility note for `prioritizePostsByLocale`/`getAllTags()`.
- Added deployment note for Git automation (Vercel vs writable server).
- Specified Next.js 15+ params typing and admin error boundary pattern.
- Documented that project does not use `next-intl`; admin UI single language unless i18n added later.

**LinkedIn API (immediate + scheduled):** Both immediate and scheduled sharing use LinkedIn UGC Post API (no share URL for primary flow). Post text is generated by Gemini (from blog title/description); user can override. New: task 12b (Gemini LinkedIn post text endpoint), LinkedIn post-text prompts in `lib/gemini-prompts.ts`, task 13 updated to immediate share via API + Gemini, task 15 cron uses Gemini when no custom text; verification table and Best Practices updated accordingly.

**Ready for TODO.md:** Plan is consistent with current codebase, dependency set, and project rules; task list is numbered and verification criteria are defined; refinements above are reflected in the plan body.
