---
description: When working with schemas, data models, forms.
alwaysApply: false
---

# Validation Rules for Plutony Web Project

## Zod Validation Best Practices

### Centralized Schema Management

**CRITICAL: Always use centralized Zod schemas from `@/app/lib/schemas.ts`**

```typescript
// ✅ ALWAYS DO: Use centralized schemas
import { contentAnalysisSchema, contactSchema, parentReviewSchema } from '@/lib/schemas'

// ❌ NEVER DO: Create inline schemas
const localSchema = z.object({
  name: z.string(),
  email: z.string().email()
})
```

### Available Schemas

**From `@/lib/schemas.ts`:**

- **`contentAnalysisSchema`** - For content analysis API requests
- **`contactSchema`** - For contact form submissions
- **`parentReviewSchema`** - For parent review submissions

### Schema Design Principles

**1. Use Transform Functions for Sanitization:**

```typescript
// ✅ Good: Transform with sanitization
z.string()
  .min(2, 'Ad en az 2 karakter olmalı')
  .max(100, 'Ad en fazla 100 karakter olabilir')
  .transform(val => val.trim().replace(/[<>]/g, ''))

// ❌ Bad: No sanitization
z.string().min(2).max(100)
```

**2. Provide Turkish Error Messages:**

```typescript
// ✅ Good: Turkish error messages
z.string().email('Geçerli bir email adresi girin')
z.enum(['option1', 'option2'], {
  errorMap: () => ({ message: 'Geçerli bir seçenek belirleyin' })
})

// ❌ Bad: Default English messages
z.string().email()
z.enum(['option1', 'option2'])
```

**3. Use Proper Type Inference:**

```typescript
// ✅ Good: Export inferred types
export const contactSchema = z.object({...})
export type ContactFormRequest = z.infer<typeof contactSchema>

// ❌ Bad: Manual type definitions
interface ContactFormRequest {
  name: string
  email: string
}
```

### API Validation Pattern

**Standard API validation pattern:**

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { contentAnalysisSchema } from '@/lib/schemas'

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    // Validate with Zod schema
    const validation = contentAnalysisSchema.safeParse(body)
    
    if (!validation.success) {
      const errorMessages = validation.error.errors.map((err: any) => err.message).join(', ')
      return NextResponse.json(
        { error: `Geçersiz giriş verileri: ${errorMessages}` },
        { status: 400 }
      )
    }
    
    // Use validated data
    const sanitizedData = validation.data
    
    // Process request...
    
  } catch (error) {
    return NextResponse.json(
      { error: 'Sunucu hatası' },
      { status: 500 }
    )
  }
}
```

### Form Validation Pattern

**Server Action validation pattern:**

```typescript
import { contactSchema } from '@/lib/schemas'

export async function submitContact(formData: FormData) {
  try {
    const rawData = {
      name: String(formData.get("name") || ''),
      email: String(formData.get("email") || ''),
      subject: String(formData.get("subject") || ''),
      message: String(formData.get("message") || ''),
    }

    // Validate and sanitize with Zod
    const data = contactSchema.parse(rawData)
    
    // Process form submission...
    
  } catch (error) {
    if (error instanceof z.ZodError) {
      const errorMessages = error.errors.map((err: any) => err.message).join(", ")
      return { 
        success: false, 
        message: `Form verilerinde hata var: ${errorMessages}` 
      }
    }
    
    return { 
      success: false, 
      message: "Bir hata oluştu" 
    }
  }
}
```

### Schema Extension Rules

**When extending schemas:**

1. **Add to centralized file**: Always extend schemas in `@/app/lib/schemas.ts`
2. **Maintain consistency**: Follow existing patterns and naming
3. **Update types**: Export new inferred types
4. **Document changes**: Update CHANGELOG.md

**Example extension:**

```typescript
// ✅ Good: Extend existing schema
export const extendedContactSchema = contactSchema.extend({
  phone: z.string()
    .min(10, 'Telefon numarası en az 10 karakter olmalı')
    .optional()
    .transform(val => val?.trim().replace(/\D/g, ''))
})

// ❌ Bad: Create separate schema
export const phoneContactSchema = z.object({
  name: z.string(),
  email: z.string().email(),
  phone: z.string()
})
```

### Validation Security Rules

**MANDATORY security practices:**

1. **Always sanitize input**: Use `.transform()` for cleaning
2. **Validate all fields**: Never trust client-side validation
3. **Use type-safe parsing**: Always use `.safeParse()` in API routes
4. **Handle errors gracefully**: Provide user-friendly error messages
5. **Log validation failures**: Track suspicious input patterns
# Validation Rules for Plutony Web Project

## Zod Validation Best Practices

### Centralized Schema Management

**CRITICAL: Always use centralized Zod schemas from `@/app/lib/schemas.ts`**

```typescript
// ✅ ALWAYS DO: Use centralized schemas
import { contentAnalysisSchema, contactSchema, parentReviewSchema } from '@/lib/schemas'

// ❌ NEVER DO: Create inline schemas
const localSchema = z.object({
  name: z.string(),
  email: z.string().email()
})
```

### Available Schemas

**From `@/lib/schemas.ts`:**

- **`contentAnalysisSchema`** - For content analysis API requests
- **`contactSchema`** - For contact form submissions
- **`parentReviewSchema`** - For parent review submissions

### Schema Design Principles

**1. Use Transform Functions for Sanitization:**

```typescript
// ✅ Good: Transform with sanitization
z.string()
  .min(2, 'Ad en az 2 karakter olmalı')
  .max(100, 'Ad en fazla 100 karakter olabilir')
  .transform(val => val.trim().replace(/[<>]/g, ''))

// ❌ Bad: No sanitization
z.string().min(2).max(100)
```

**2. Provide Turkish Error Messages:**

```typescript
// ✅ Good: Turkish error messages
z.string().email('Geçerli bir email adresi girin')
z.enum(['option1', 'option2'], {
  errorMap: () => ({ message: 'Geçerli bir seçenek belirleyin' })
})

// ❌ Bad: Default English messages
z.string().email()
z.enum(['option1', 'option2'])
```

**3. Use Proper Type Inference:**

```typescript
// ✅ Good: Export inferred types
export const contactSchema = z.object({...})
export type ContactFormRequest = z.infer<typeof contactSchema>

// ❌ Bad: Manual type definitions
interface ContactFormRequest {
  name: string
  email: string
}
```

### API Validation Pattern

**Standard API validation pattern:**

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { contentAnalysisSchema } from '@/lib/schemas'

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    // Validate with Zod schema
    const validation = contentAnalysisSchema.safeParse(body)
    
    if (!validation.success) {
      const errorMessages = validation.error.errors.map((err: any) => err.message).join(', ')
      return NextResponse.json(
        { error: `Geçersiz giriş verileri: ${errorMessages}` },
        { status: 400 }
      )
    }
    
    // Use validated data
    const sanitizedData = validation.data
    
    // Process request...
    
  } catch (error) {
    return NextResponse.json(
      { error: 'Sunucu hatası' },
      { status: 500 }
    )
  }
}
```

### Form Validation Pattern

**Server Action validation pattern:**

```typescript
import { contactSchema } from '@/lib/schemas'

export async function submitContact(formData: FormData) {
  try {
    const rawData = {
      name: String(formData.get("name") || ''),
      email: String(formData.get("email") || ''),
      subject: String(formData.get("subject") || ''),
      message: String(formData.get("message") || ''),
    }

    // Validate and sanitize with Zod
    const data = contactSchema.parse(rawData)
    
    // Process form submission...
    
  } catch (error) {
    if (error instanceof z.ZodError) {
      const errorMessages = error.errors.map((err: any) => err.message).join(", ")
      return { 
        success: false, 
        message: `Form verilerinde hata var: ${errorMessages}` 
      }
    }
    
    return { 
      success: false, 
      message: "Bir hata oluştu" 
    }
  }
}
```

### Schema Extension Rules

**When extending schemas:**

1. **Add to centralized file**: Always extend schemas in `@/app/lib/schemas.ts`
2. **Maintain consistency**: Follow existing patterns and naming
3. **Update types**: Export new inferred types
4. **Document changes**: Update CHANGELOG.md

**Example extension:**

```typescript
// ✅ Good: Extend existing schema
export const extendedContactSchema = contactSchema.extend({
  phone: z.string()
    .min(10, 'Telefon numarası en az 10 karakter olmalı')
    .optional()
    .transform(val => val?.trim().replace(/\D/g, ''))
})

// ❌ Bad: Create separate schema
export const phoneContactSchema = z.object({
  name: z.string(),
  email: z.string().email(),
  phone: z.string()
})
```

### Validation Security Rules

**MANDATORY security practices:**

1. **Always sanitize input**: Use `.transform()` for cleaning
2. **Validate all fields**: Never trust client-side validation
3. **Use type-safe parsing**: Always use `.safeParse()` in API routes
4. **Handle errors gracefully**: Provide user-friendly error messages
5. **Log validation failures**: Track suspicious input patterns
