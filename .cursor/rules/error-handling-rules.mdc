---
description: Next.js 15+ error handling patterns and best practices for THOF project
alwaysApply: false
---

# Error Handling Rules for THOF Project (Next.js 15+)

## ğŸš¨ Core Principles

1. **Next.js 15+ Error Boundaries**: Use proper error.tsx files for route-level error handling
2. **Client-Side Error Management**: Use ErrorBoundary components for client-side errors
3. **Centralized Error Logging**: All errors must be logged and handled consistently
4. **User-Friendly Messages**: Always provide clear Turkish error messages to users
5. **Type Safety**: Use proper TypeScript error typing and handling

## ğŸ“‹ Next.js 15+ Error Handling Architecture

### Route-Level Error Boundaries (REQUIRED)

**CRITICAL: Every route segment must have an error.tsx file:**

```typescript
// âœ… REQUIRED: src/app/error.tsx (Global error boundary)
'use client'

import { useEffect } from 'react'
import { Button } from '@/components/ui/Button'
import { Card } from '@/components/ui/Card'

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  useEffect(() => {
    console.error('Application error:', error)
  }, [error])

  return (
    <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4">
      <Card className="max-w-md w-full p-8 text-center">
        <div className="text-6xl mb-4">âš ï¸</div>
        <h1 className="text-2xl font-bold text-gray-900 mb-2">
          Bir Hata OluÅŸtu
        </h1>
        <p className="text-gray-600 mb-6">
          ÃœzgÃ¼nÃ¼z, beklenmeyen bir hata oluÅŸtu. LÃ¼tfen tekrar deneyin.
        </p>
        <Button onClick={reset} className="w-full">
          Tekrar Dene
        </Button>
      </Card>
    </div>
  )
}
```

```typescript
// âœ… REQUIRED: src/app/[locale]/not-found.tsx (Custom 404)
import { Button } from '@/components/ui/Button'
import { Card } from '@/components/ui/Card'
import Link from 'next/link'

export default function NotFound() {
  return (
    <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4">
      <Card className="max-w-md w-full p-8 text-center">
        <div className="text-6xl mb-4">ğŸ”</div>
        <h1 className="text-2xl font-bold text-gray-900 mb-2">
          Sayfa BulunamadÄ±
        </h1>
        <p className="text-gray-600 mb-6">
          AradÄ±ÄŸÄ±nÄ±z sayfa mevcut deÄŸil veya taÅŸÄ±nmÄ±ÅŸ olabilir.
        </p>
        <Link href="/" className="block">
          <Button className="w-full">Ana Sayfaya DÃ¶n</Button>
        </Link>
      </Card>
    </div>
  )
}
```

```typescript
// âœ… REQUIRED: src/app/admin/error.tsx (Admin-specific errors)
'use client'

export default function AdminError({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4">
      <Card className="max-w-md w-full p-8 text-center">
        <div className="text-6xl mb-4">ğŸ› ï¸</div>
        <h1 className="text-2xl font-bold text-gray-900 mb-2">
          YÃ¶netim Paneli HatasÄ±
        </h1>
        <p className="text-gray-600 mb-6">
          YÃ¶netim panelinde bir hata oluÅŸtu. LÃ¼tfen tekrar deneyin.
        </p>
        <Button onClick={reset} className="w-full">
          Tekrar Dene
        </Button>
      </Card>
    </div>
  )
}
```

### Server Component Error Handling

**CORRECT: Server component error patterns:**

```typescript
// âœ… GOOD: Server component with proper error handling
import { notFound } from 'next/navigation'

export default async function ServerPage({ params }: { params: Promise<{ id: string }> }) {
  const { id } = await params // âœ… Always await params
  
  try {
    const data = await fetchData(id)
    
    if (!data) {
      notFound() // âœ… Use Next.js notFound() for 404s
    }
    
    return <div>{data.content}</div>
  } catch (error) {
    console.error('Server component error:', error)
    throw error // âœ… Let error.tsx handle it
  }
}
```

### Client Component Error Handling

**CORRECT: Client components handle their own loading/error states:**

```typescript
// âœ… GOOD: Client component with internal error handling
'use client'

import { useState, useEffect } from 'react'
import { LoadingSpinner } from '@/components/ui/LoadingSpinner'
import { Alert } from '@/components/ui/Alert'

export function ClientDataList() {
  const [data, setData] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    fetchData()
      .then(setData)
      .catch((err) => {
        console.error('Client fetch error:', err)
        setError('Veri yÃ¼klenirken hata oluÅŸtu')
      })
      .finally(() => setLoading(false))
  }, [])

  if (loading) return <LoadingSpinner />
  if (error) return <Alert variant="error">{error}</Alert>
  if (!data) return <div>Veri bulunamadÄ±</div>

  return <div>{/* Render data */}</div>
}

// âŒ WRONG: Don't wrap client components with Suspense
// <Suspense fallback={<Loading />}>
//   <ClientDataList /> {/* Already handles loading internally */}
// </Suspense>
```

## ğŸ¯ API Route Error Handling

### Proper API Error Responses

```typescript
// âœ… GOOD: API route error handling
import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'

const schema = z.object({
  title: z.string().min(1, 'BaÅŸlÄ±k gereklidir'),
  content: z.string().min(1, 'Ä°Ã§erik gereklidir'),
})

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const validation = schema.safeParse(body)
    
    if (!validation.success) {
      return NextResponse.json(
        { 
          error: 'GeÃ§ersiz veri',
          details: validation.error.errors.map(e => e.message)
        },
        { status: 400 }
      )
    }
    
    const result = await processData(validation.data)
    return NextResponse.json(result)
    
  } catch (error) {
    console.error('API route error:', error)
    
    return NextResponse.json(
      { error: 'Sunucu hatasÄ± oluÅŸtu' },
      { status: 500 }
    )
  }
}
```

## ğŸ“ Error Messages Standards

### Turkish Error Messages

**CRITICAL: Always provide clear Turkish error messages:**

```typescript
// âœ… GOOD: Standard Turkish error messages
export const errorMessages = {
  // Form validation
  required: 'Bu alan zorunludur',
  email: 'GeÃ§erli bir e-posta adresi girin',
  minLength: (min: number) => `En az ${min} karakter olmalÄ±dÄ±r`,
  maxLength: (max: number) => `En fazla ${max} karakter olmalÄ±dÄ±r`,
  
  // Network errors
  network: 'BaÄŸlantÄ± hatasÄ± oluÅŸtu. Ä°nternet baÄŸlantÄ±nÄ±zÄ± kontrol edin',
  timeout: 'Ä°stek zaman aÅŸÄ±mÄ±na uÄŸradÄ±. Tekrar deneyin',
  
  // Authentication
  unauthorized: 'Bu iÅŸlem iÃ§in giriÅŸ yapmanÄ±z gerekiyor',
  forbidden: 'Bu iÅŸlemi yapmaya yetkiniz yok',
  invalidCredentials: 'E-posta veya ÅŸifre hatalÄ±',
  
  // Server errors
  serverError: 'Sunucu hatasÄ± oluÅŸtu. LÃ¼tfen daha sonra tekrar deneyin',
  notFound: 'AradÄ±ÄŸÄ±nÄ±z sayfa bulunamadÄ±',
  
  // Database errors
  databaseError: 'VeritabanÄ± hatasÄ± oluÅŸtu',
  duplicateEntry: 'Bu kayÄ±t zaten mevcut',
  
  // File upload
  fileTooBig: 'Dosya boyutu Ã§ok bÃ¼yÃ¼k',
  invalidFileType: 'Desteklenmeyen dosya tÃ¼rÃ¼',
  uploadFailed: 'Dosya yÃ¼kleme baÅŸarÄ±sÄ±z oldu',
}

// âŒ WRONG: English or unclear messages
const badMessages = {
  required: 'Required field',
  network: 'Network error',
  serverError: 'Server error',
}
```

## ğŸ”„ Error Recovery Patterns

### Graceful Degradation

```typescript
// âœ… GOOD: Graceful degradation with fallbacks
export async function getDataWithFallback(id: string) {
  try {
    // Try primary data source
    return await getPrimaryData(id)
  } catch (primaryError) {
    console.warn('Primary data source failed:', primaryError)
    
    try {
      // Fallback to cache
      return await getCachedData(id)
    } catch (cacheError) {
      console.warn('Cache fallback failed:', cacheError)
      
      // Final fallback to default data
      return getDefaultData()
    }
  }
}
```

### Retry Logic

```typescript
// âœ… GOOD: Exponential backoff retry
export async function withRetry<T>(
  operation: () => Promise<T>,
  maxRetries = 3,
  baseDelay = 1000
): Promise<T> {
  let lastError: Error
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation()
    } catch (error) {
      lastError = error instanceof Error ? error : new Error('Unknown error')
      
      if (attempt === maxRetries) {
        throw lastError
      }
      
      // Exponential backoff
      const delay = baseDelay * Math.pow(2, attempt - 1)
      await new Promise(resolve => setTimeout(resolve, delay))
      
      console.warn(`Attempt ${attempt} failed, retrying in ${delay}ms:`, error)
    }
  }
  
  throw lastError!
}
```

## ğŸ§ª Error Testing

### Test Error Boundaries

```typescript
// âœ… GOOD: Test error handling
import { render, screen } from '@testing-library/react'
import { ErrorBoundary } from 'react-error-boundary'

const ThrowError = ({ shouldThrow }: { shouldThrow: boolean }) => {
  if (shouldThrow) {
    throw new Error('Test error')
  }
  return <div>No error</div>
}

describe('Error Handling', () => {
  it('should display error boundary when component throws', () => {
    render(
      <ErrorBoundary fallback={<div>Something went wrong</div>}>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    )
    
    expect(screen.getByText('Something went wrong')).toBeInTheDocument()
  })
  
  it('should handle API errors gracefully', async () => {
    // Mock failed API call
    global.fetch = jest.fn().mockRejectedValue(new Error('API Error'))
    
    const { result } = renderHook(() => useApiData())
    
    await waitFor(() => {
      expect(result.current.error).toBe('Veri yÃ¼klenirken hata oluÅŸtu')
    })
  })
})
```

## ğŸ“Š Error Monitoring

### Error Logging Standards

```typescript
// âœ… GOOD: Structured error logging
interface ErrorContext {
  userId?: string
  action: string
  component: string
  timestamp: string
  userAgent?: string
  url?: string
}

export function logError(error: Error, context: ErrorContext) {
  const errorData = {
    message: error.message,
    stack: error.stack,
    name: error.name,
    context,
    timestamp: new Date().toISOString(),
  }
  
  // Log to console in development
  if (process.env.NODE_ENV === 'development') {
    console.error('Error logged:', errorData)
  }
  
  // Send to monitoring service in production
  if (process.env.NODE_ENV === 'production') {
    // Send to Sentry, LogRocket, etc.
    sendToMonitoring(errorData)
  }
}

// Usage
try {
  await riskyOperation()
} catch (error) {
  logError(error instanceof Error ? error : new Error('Unknown error'), {
    action: 'riskyOperation',
    component: 'DataProcessor',
    timestamp: new Date().toISOString(),
  })
  throw error
}
```

## ğŸ”’ Security Considerations

### Safe Error Messages

```typescript
// âœ… GOOD: Safe error messages for production
export function getSafeErrorMessage(error: unknown): string {
  if (process.env.NODE_ENV === 'development') {
    // Show detailed errors in development
    return error instanceof Error ? error.message : 'Unknown error'
  }
  
  // Generic messages in production
  if (error instanceof ValidationError) {
    return 'Girilen veriler geÃ§ersiz'
  }
  
  if (error instanceof AuthError) {
    return 'GiriÅŸ yapÄ±lamadÄ±'
  }
  
  if (error instanceof NotFoundError) {
    return 'Ä°stenen kaynak bulunamadÄ±'
  }
  
  // Generic fallback
  return 'Bir hata oluÅŸtu. LÃ¼tfen tekrar deneyin'
}

// âŒ WRONG: Exposing sensitive information
return `Database connection failed: ${dbConnectionString}`
```

Remember: Proper error handling is critical for application reliability and user experience. Always handle errors gracefully and provide clear feedback to users while maintaining security.